import groovy.json.JsonSlurper
import com.google.common.collect.Sets

/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This is the build configuration for the google-ads-java subproject. It
 * depends on the google-ads-annotation-processing subproject.
 */

plugins {
  id 'com.google.api-ads.java-conventions'
  id 'com.google.protobuf' version '0.8.15'
  id "com.github.hierynomus.license-report" version "0.15.0"
  id 'com.github.johnrengelman.shadow' version '6.1.0'
}

description = 'Google Ads API client library for Java'

sourceSets {
  test {
    proto {
      srcDir 'src/test/resources/protos/'
    }
  }
  // Provides functional tests that can be bypassed (e.g. when running
  // without an ads.properties file).
  functionalTest {
    java {
      srcDir 'src/test/functional/java'
    }
    resources {
      srcDir 'src/test/functional/resources'
    }
    compileClasspath += sourceSets.main.output
    runtimeClasspath += sourceSets.main.output
  }
}

protobuf {
  protoc {
    artifact = 'com.google.protobuf:protoc:3.15.0-rc-1'
  }
}

configurations {
  shadeTest
  functionalTestImplementation.extendsFrom testImplementation
  functionalTestRuntimeOnly.extendsFrom testRuntimeOnly
}

dependencies {
  implementation 'io.netty:netty-tcnative-boringssl-static:2.0.26.Final'
  implementation 'org.slf4j:slf4j-api:1.7.25'
  implementation project(':google-ads-annotation-processing')
  annotationProcessor project(':google-ads-annotation-processing')
  annotationProcessor 'com.google.auto.value:auto-value:1.7.3'
  testImplementation 'org.hamcrest:java-hamcrest:2.0.0.0'
  testImplementation 'org.mockito:mockito-all:1.9.5'
  testImplementation 'com.google.api:gax-grpc:1.65.1:testlib'
  testImplementation 'io.grpc:grpc-context:1.30.0'
  testImplementation 'com.google.truth:truth:0.27'
  testImplementation 'com.google.auto.value:auto-value-annotations:1.7.3'
  shadeTest 'junit:junit:4.13.1'
}

task functionalTest(type: Test) {
  description = "Runs functional tests"
  testClassesDirs = sourceSets.functionalTest.output.classesDirs
  classpath = sourceSets.functionalTest.runtimeClasspath
}

// --------------------- third_party directory generation ----------------------

task generateThirdPartyDirectory() {
  description = "Generates the third_party directory (containing dependencies" +
      " + licenses)"

  ext {
    thirdPartyDir = file '../third_party'
  }
  dependsOn 'createThirdPartyDirectory'
  dependsOn 'copyThirdPartyArtifacts'
  dependsOn 'copyLicenses'
}

task createThirdPartyDirectory() {
  doLast {
    def thirdPartyDir = tasks.generateThirdPartyDirectory.thirdPartyDir
    if (thirdPartyDir.exists() && !thirdPartyDir.deleteDir()) {
      throw new GradleException('third_party exists but failed to delete')
    }
    if (!thirdPartyDir.mkdir()) {
      throw new GradleException("Failed to create third_party directory")
    }
  }
}

task generateLicenses(type: nl.javadude.gradle.plugins.license.DownloadLicenses) {
  description = "Copies the license report into the third_party directory"

  includeProjectDependencies = true
  // Works around issue where the plugin looks at the deprecated 'compile'
  // configuration by default.
  dependencyConfiguration = 'runtimeClasspath'

  // Defines variables for the expected output files.
  def outputDirectory = tasks.downloadLicenses.outputs.files.files.find()
  def outputFilePattern = outputDirectory.absoluteFile.path + File.separator + "dependency-license."
  def licenses = ["html", "json", "xml"].collect({ file(outputFilePattern + it) })

  // Exports the output file names for use elsewhere.
  ext {
    licenseFiles = licenses
  }
}

task verifyLicenses() {
  description = "Verifies that the licenses used by 3P dependencies are allowed"
  dependsOn 'generateLicenses'

  doLast {
    // Reads the dependency-license.json file generated by generateLicenses.
    def inputFile = tasks.generateLicenses.licenseFiles.find { it.path.endsWith(".json") }
    def json = new JsonSlurper().parseText(inputFile.text)
    // Gets all the licenses except those for ourselves (which aren't set yet).
    def licenses = json
        .dependencies
        .findAll { !it.name.startsWith("com.google.api-ads") }
        .licenses
        .name
        .flatten() as Set
    // Defines licenses which are allowed. Update this list if you need to add
    // a new license.
    def allowedLicenses = [
        "Apache License, Version 2.0",
        "The Apache License, Version 2.0",
        "The Apache Software License, Version 2.0",
        "Apache 2.0",
        "Apache-2.0",
        "Apache 2",
        "BSD",
        "BSD 3-clause",
        "3-Clause BSD License",
        "The MIT License",
        "MIT License",
        "MIT license",
        "BSD New license",
        "GNU General Public License, version 2 (GPL2), with the classpath exception",
        "CDDL + GPLv2 with classpath exception"
    ] as Set
    // Computes which licenses are in use but not permitted.
    def notAllowed = Sets.difference(licenses, allowedLicenses)
    if (!notAllowed.empty) {
      throw new GradleException(
          """Licenses found which were not allowed: ${notAllowed}
- Note that this script is not very smart. It doesn't attempt to do partial
string comparison on the license name. It is possible that the new license is
already allowed with a different spelling. If the new license is already allowed
just add the new spelling to google-ads/build.gradle.
- Otherwise you need to consider if we should accept this new license. For 
Googlers, there is a company policy for this available internally.""")
    }
  }
}

task copyLicenses(type: Copy) {
  description = "Copies licenses from build directory to third_party"
  dependsOn 'generateLicenses'
  mustRunAfter 'createThirdPartyDirectory'

  from tasks.generateLicenses.licenseFiles
  into tasks.generateThirdPartyDirectory.thirdPartyDir
  // Rename files to LICENSES.*
  eachFile {
    if (!path.contains("dependency-license")) {
      throw new GradleException(
          "Expecting files named dependency-license.*, found: " + path)
    }
    path = path.replace("dependency-license", "LICENSES")
  }
  doLast {
    // Fails the build if we didn't copy everything. Gradle will fail silently if
    // it cannot copy one of the inputs which is dangerous when you're dealing
    // with legal obligations.
    if (tasks.generateLicenses.licenseFiles.size() != inputs.sourceFiles.size()) {
      throw new GradleException(
          "Failed to locate files to copy from. Expected: "
              + tasks.generateLicenses.licenseFiles
              + " but was: " + inputs.sourceFiles.toList())
    }
  }
}

task copyThirdPartyArtifacts(type: Copy) {
  description = "Copies the sources and binaries of dependencies to third_party"
  mustRunAfter 'createThirdPartyDirectory'

  // Requires that this task is always run since it's hard to detect when the
  // dependencies have changed.
  outputs.upToDateWhen { false }

  def dependencies = configurations.runtimeClasspath
      .resolvedConfiguration
      .resolvedArtifacts
      .collect {
        project.dependencies.create([
            group     : it.moduleVersion.id.group,
            name      : it.moduleVersion.id.name,
            version   : it.moduleVersion.id.version,
            classifier: "sources"
        ])
      }
  def files = configurations.detachedConfiguration(dependencies as Dependency[])
      .resolvedConfiguration
      .lenientConfiguration
      .getFiles(Specs.SATISFIES_ALL)
  if (files.isEmpty()) {
    throw new GradleException("No source files provided")
  }
  if (files.size() < dependencies.size()) {
    throw new GradleException("Missing dependencies num files < num " +
        "dependencies, ${files.size()} < ${dependencies.size()}")
  }
  from files
  into tasks.generateThirdPartyDirectory.thirdPartyDir
  doLast {
    logger.info('Resolved third party dependencies')
    files.each {
      logger.debug(" - ${it.path}")
    }
  }
}

// ------------------------------ Shadow jar -----------------------------------

shadowJar {
  description = "Generates a jar with dependencies"

  archiveClassifier.set "jar-with-dependencies"

  // Requires that this task is always run and does not build from the cache.
  outputs.upToDateWhen { false }

  // Updates the META-INF/services directory with the services from dependencies
  mergeServiceFiles()

  // Includes the license report with the shadow jar.
  dependsOn 'generateLicenses'
  from tasks.generateLicenses.licenseFiles

  finalizedBy 'testShadowJar'
}

task testShadowJar {
  description = "Executes functional tests for shadow jar"

  dependsOn shadowJar
  dependsOn functionalTestClasses

  doLast {
    javaexec {
      mainClass = "com.google.ads.googleads.lib.SmokeTest"
      // Uses a special configuration to run the smoke tests. Allows us to
      // replace the google-ads dependency with the shaded artifact so we can
      // test it. Otherwise we'd just run end up running the smoke tests on
      // the normal jar twice.
      classpath = project.configurations.shadeTest +
          // Uses the compiler output directly, rather than getting the
          // dependencies from the configuration (since this would include
          // the artifact we're trying to ignore).
          files(sourceSets.functionalTest.output.classesDirs.files,
              shadowJar.outputs.files)
    }
  }
}
