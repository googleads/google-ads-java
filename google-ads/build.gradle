import groovy.json.JsonSlurper
import com.google.common.collect.Sets

/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This is the build configuration for the google-ads-java subproject. It
 * depends on the google-ads-annotation-processing subproject.
 */

plugins {
  id 'com.google.api-ads.java-conventions'
  id 'com.google.protobuf' version '0.8.15'
  id "com.github.hierynomus.license-report" version "0.15.0"
}

description = 'Google Ads API client library for Java'

sourceSets {
    main {
        java {
            // Includes the generated classes from the google-ads-codegen module
            // to be compiled by google-ads. The generated sources depend on
            // imports from google-ads, so are not compiled with
            // google-ads-codegen. Confusingly we have an api dependency on
            // google-ads-codegen here, however this only exposes the stubs to
            // the main library.
            srcDir new File(project.parent.findProject("google-ads-codegen").buildDir, "generated/catalog")
        }
    }
    test {
        proto {
            srcDir 'src/test/resources/protos/'
        }
    }
}
sourceSets.test.java.srcDir new File(buildDir, 'generated/source/proto/test')

protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.15.0-rc-1'
    }
}

dependencies {
    api project(':google-ads-codegen')
    implementation 'io.netty:netty-tcnative-boringssl-static:2.0.26.Final'
    implementation 'org.slf4j:slf4j-api:1.7.25'
    annotationProcessor 'com.google.auto.value:auto-value:1.7.3'
    testImplementation 'org.hamcrest:java-hamcrest:2.0.0.0'
    testImplementation 'org.mockito:mockito-all:1.9.5'
    testImplementation 'com.google.api:gax-grpc::testlib'
    testImplementation 'io.grpc:grpc-context:1.30.0'
    testImplementation 'com.google.truth:truth:0.27'
    implementation 'com.google.auto.value:auto-value-annotations:1.7.3'
    testImplementation 'com.google.auto.value:auto-value-annotations:1.7.3'
    testImplementation testFixtures(project(':google-ads-codegen'))
}

compileJava {
    dependsOn(":google-ads-codegen:generateCode")
}


// --------------------- third_party directory generation ----------------------

task generateThirdPartyDirectory() {
    description = "Generates the third_party directory (containing dependencies" +
            " + licenses)"

    ext {
        thirdPartyDir = file '../third_party'
    }
    dependsOn 'createThirdPartyDirectory'
    dependsOn 'copyThirdPartySources'
    dependsOn 'copyThirdPartyBinaries'
    dependsOn 'copyLicenses'
}

task createThirdPartyDirectory() {
    doLast {
        def thirdPartyDir = tasks.generateThirdPartyDirectory.thirdPartyDir
        if (thirdPartyDir.exists() && !thirdPartyDir.deleteDir()) {
            throw new GradleException('third_party exists but failed to delete')
        }
        if (!thirdPartyDir.mkdir()) {
            throw new GradleException("Failed to create third_party directory")
        }
    }
}

task generateLicenses(type: nl.javadude.gradle.plugins.license.DownloadLicenses) {
    description = "Copies the license report into the third_party directory"

    includeProjectDependencies = true

    // Works around issue where the plugin looks at the deprecated 'compile'
    // configuration by default.
    dependencyConfiguration = 'runtimeClasspath'
}

task verifyLicenses() {
    description = "Verifies that the licenses used by 3P dependencies are allowed"
    dependsOn 'generateLicenses'

    doLast {
        // Reads the dependency-license.json file generated by generateLicenses.
        def inputFile = tasks.generateLicenses.outputs.files.files.find { it.path.endsWith(".json") }
        def json = new JsonSlurper().parseText(inputFile.text)
        // Gets all the licenses except those for ourselves (which aren't set yet).
        def licenses = json
                .dependencies
                .findAll { !it.name.startsWith("com.google.api-ads") }
                .licenses
                .name
                .flatten() as Set
        // Defines licenses which are allowed. Update this list if you need to add
        // a new license.
        def allowedLicenses = [
                "Apache License, Version 2.0",
                "The Apache License, Version 2.0",
                "The Apache Software License, Version 2.0",
                "Apache 2.0",
                "Apache-2.0",
                "Apache 2",
                "BSD",
                "BSD 3-clause",
                "3-Clause BSD License",
                "The MIT License",
                "MIT License",
                "MIT license",
                "BSD New license",
                "GNU General Public License, version 2 (GPL2), with the classpath exception",
                "CDDL + GPLv2 with classpath exception"
        ] as Set
        // Computes which licenses are in use but not permitted.
        def notAllowed = Sets.difference(licenses, allowedLicenses)
        if (!notAllowed.empty) {
            throw new GradleException(
                    """Licenses found which were not allowed: ${notAllowed}
- Note that this script is not very smart. It doesn't attempt to do partial
string comparison on the license name. It is possible that the new license is
already allowed with a different spelling. If the new license is already allowed
just add the new spelling to google-ads/build.gradle.
- Otherwise you need to consider if we should accept this new license. For 
Googlers, there is a company policy for this available internally.""")
        }
    }
}

task copyLicenses(type: Copy) {
    description = "Copies licenses from build directory to third_party"
    dependsOn 'generateLicenses'
    mustRunAfter 'createThirdPartyDirectory'

    from new File(tasks.generateLicenses.xmlDestination.getAbsolutePath(), "dependency-license.json"),
            new File(tasks.generateLicenses.xmlDestination.getAbsolutePath(), "dependency-license.html"),
            new File(tasks.generateLicenses.xmlDestination.getAbsolutePath(), "dependency-license.xml")
    into tasks.generateThirdPartyDirectory.thirdPartyDir
    eachFile {
        if (!path.contains("dependency-license")) {
            throw new GradleException(
                    "Expecting files named dependency-license.*, found: " + path)
        }
        path = path.replace("dependency-license", "LICENSES")
    }
    doLast {
        // Fails the build if we didn't copy everything. Gradle will fail silently if
        // it cannot copy one of the inputs which is dangerous when you're dealing
        // with legal obligations.
        //
        // We're expecting exactly 3 input files, a JSON, XML and HTML version of
        // the license report.
        if (3 != inputs.sourceFiles.size()) {
            throw new GradleException(
                    "Failed to locate files to copy from. Expected: 3 but was: "
                            + inputs.sourceFiles.toList())
        }
    }
}

task copyThirdPartySources(type: Copy) {
    description = "Copies the sources and binaries of dependencies to third_party"
    mustRunAfter 'createThirdPartyDirectory'

    // Requires that this task is always run since it's hard to detect when the
    // dependencies have changed.
    outputs.upToDateWhen { false }

    def componentIds = configurations.runtimeClasspath
            .incoming
            .resolutionResult
            .allDependencies
            .stream()
    // Avoids failing the build with cryptic errors when a bad dependency is
    // added.
            .filter { it.hasProperty("selected") != null }
    // Avoids attempting to download sources for projects in the build.
            .filter { !(it.selected.id instanceof ProjectComponentIdentifier) }
    // Avoids attempting to download sources for Maven BOMs.
            .filter { !it.getResolvedVariant().getDisplayName().equals("platform-runtime") }
            .collect { it.selected.id } as Set

    def resolvedComponents = project.dependencies.createArtifactResolutionQuery()
            .forComponents(componentIds)
            .withArtifacts(JvmLibrary, SourcesArtifact)
            .execute()
            .resolvedComponents

    // Allows a dependency to be excluded from having its sources cached.
    // There should be a _very_ good reason for anything being in here.
    final def exemptionEligible = [
            // Google owned dummy module which doens't need any code.
            "com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava"
    ]

    // Grabs the source jars.
    def files = []
    for (componentId in componentIds) {
        def resolvedComponentsForId = resolvedComponents.findAll { (it.id == componentId) }
        if (resolvedComponentsForId.size() != 1) {
            throw new GradleException("Failed to resolve component for ${componentId}. Got: " + resolvedComponentsForId)
        }
        def sources = resolvedComponentsForId[0].getArtifacts(SourcesArtifact)
        if (sources.size() == 1) {
            files.add(sources[0].file)
        } else if (exemptionEligible.contains(componentId.toString())) {
            logger.debug("Allowing exemption for ${componentId}")
        } else {
            throw new RuntimeException("Unable to resolve sources for ${componentId}. Got: ${sources}")
        }
    }
    from files
    into tasks.generateThirdPartyDirectory.thirdPartyDir
    doLast {
        logger.info('Resolved third party sources')
        files.each {
            logger.debug(" - ${it.path}")
        }
    }
}

// Copies the third party binaries to the third_party folder.
task copyThirdPartyBinaries(type: Copy) {
    from configurations.runtimeClasspath
    into tasks.generateThirdPartyDirectory.thirdPartyDir
}

publishing {
  publications {
    maven(MavenPublication) { publication ->
      configurePom(publication,
          "Google Ads API client library for Java - main library",
          "Main library for the Google Ads API client library for Java")
    }
  }
}
