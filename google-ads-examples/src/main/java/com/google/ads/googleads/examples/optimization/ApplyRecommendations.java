// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.ads.googleads.examples.optimization;

import com.beust.jcommander.Parameter;
import com.google.ads.googleads.examples.utils.ArgumentNames;
import com.google.ads.googleads.examples.utils.CodeSampleParams;
import com.google.ads.googleads.lib.GoogleAdsClient;
import com.google.ads.googleads.v10.enums.RecommendationTypeEnum.RecommendationType;
import com.google.ads.googleads.v10.errors.GoogleAdsError;
import com.google.ads.googleads.v10.errors.GoogleAdsException;
import com.google.ads.googleads.v10.resources.Campaign;
import com.google.ads.googleads.v10.resources.CampaignName;
import com.google.ads.googleads.v10.resources.Customer;
import com.google.ads.googleads.v10.resources.CustomerName;
import com.google.ads.googleads.v10.resources.Recommendation;
import com.google.ads.googleads.v10.resources.RecommendationName;
import com.google.ads.googleads.v10.services.ApplyRecommendationOperation;
import com.google.ads.googleads.v10.services.ApplyRecommendationResponse;
import com.google.ads.googleads.v10.services.ApplyRecommendationResult;
import com.google.ads.googleads.v10.services.GoogleAdsRow;
import com.google.ads.googleads.v10.services.GoogleAdsServiceClient;
import com.google.ads.googleads.v10.services.RecommendationServiceClient;
import com.google.ads.googleads.v10.services.SearchGoogleAdsStreamRequest;
import com.google.ads.googleads.v10.services.SearchGoogleAdsStreamResponse;
import com.google.api.gax.rpc.ServerStream;
import com.google.common.collect.ImmutableList;
import de.siegmar.fastcsv.reader.NamedCsvReader;
import de.siegmar.fastcsv.reader.NamedCsvRow;
import de.siegmar.fastcsv.writer.CsvWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class ApplyRecommendations {

  private static class ApplyRecommendationsParams extends CodeSampleParams {

    @Parameter(
        names = ArgumentNames.CUSTOMER_IDS,
        description =
            "Optionally specify a comma-separated list of customerIds to apply recommendations to.")
    private List<Long> customerIds;

    @Parameter(
        names = ArgumentNames.LOGIN_CUSTOMER_ID,
        description =
            "Optionally specify the manager account ID which provides access to the customer IDs.")
    private Long loginCustomerId;

    @Parameter(
        names = "--reportDirectory",
        description =
            "Optionally specify the path of directory to read recommendation reports and store"
                + " generated optimization reports.")
    private String reportDirectory = ".";
  }

  /**
   * Represents Recommendation, Campaign, AdGroup, CampaignBudget and the recommendation's
   * description string. This is used to hold a recommendation together with other related
   * information.
   */
  private static class AggregatedRecommendation {

    private final Recommendation recommendation;
    private final Campaign campaign;
    private final String descriptions;

    private AggregatedRecommendation(
        Recommendation recommendation, Campaign campaign, String descriptions) {
      this.recommendation = recommendation;
      this.campaign = campaign;
      this.descriptions = descriptions;
    }
  }

  public static void main(String[] args) {
    ApplyRecommendationsParams params = new ApplyRecommendationsParams();
    if (!params.parseArguments(args)) {
      // Optional: You may pass the customerIds on the command line or specify them here.
      // If neither are set, the example will apply all the recommendations found in the reports
      // generated by AcquireOptimizations.java in reportDirectory.
      params.customerIds = ImmutableList.of(Long.valueOf("INSERT_CUSTOMER_ID_HERE"));

      // Optional: You may pass the loginCustomerId on the command line or specify a loginCustomerId
      // here if and only if your access to the customerIds is via a manage account.
      params.loginCustomerId = Long.valueOf("INSERT_LOGIN_CUSTOMER_ID_HERE");

      // Optional: You may pass the reportDirectory on the command line or specify a reportDirectory
      // here. If neither are set, "." will be passed to the runExample method, and the example
      // will read recommendations from and generate reports to the current directory.
      params.reportDirectory = "INSERT_REPORT_DIRECTORY_HERE";
    }

    GoogleAdsClient googleAdsClient = null;
    try {
      GoogleAdsClient.Builder builder = GoogleAdsClient.newBuilder().fromPropertiesFile();
      if (params.loginCustomerId != null) {
        builder.setLoginCustomerId(params.loginCustomerId);
      }
      googleAdsClient = builder.build();
    } catch (FileNotFoundException fnfe) {
      System.err.printf(
          "Failed to load GoogleAdsClient configuration from file. Exception: %s%n", fnfe);
      System.exit(1);
    } catch (IOException ioe) {
      System.err.printf("Failed to create GoogleAdsClient. Exception: %s%n", ioe);
      System.exit(1);
    }

    try {
      new ApplyRecommendations()
          .runExample(googleAdsClient, params.customerIds, params.reportDirectory);
    } catch (GoogleAdsException gae) {
      // GoogleAdsException is the base class for most exceptions thrown by an API request.
      // Instances of this exception have a message and a GoogleAdsFailure that contains a
      // collection of GoogleAdsErrors that indicate the underlying causes of the
      // GoogleAdsException.
      System.err.printf(
          "Request ID %s failed due to GoogleAdsException. Underlying errors:%n",
          gae.getRequestId());
      int i = 0;
      for (GoogleAdsError googleAdsError : gae.getGoogleAdsFailure().getErrorsList()) {
        System.err.printf("  Error %d: %s%n", i++, googleAdsError);
      }
      System.exit(1);
    } catch (IOException ioe) {
      System.err.printf("Failed to generate reports. Exception: %s%n", ioe);
      System.exit(1);
    }
  }

  /**
   * Runs the example.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerIds the list of customerIds to apply recommendations to.
   * @param reportDirectory the path of directory to read and generate reports.
   * @throws IOException if a failure occurs when trying to read or generate reports.
   */
  private void runExample(
      GoogleAdsClient googleAdsClient, List<Long> customerIds, String reportDirectory)
      throws IOException {
    Path dir = Paths.get(reportDirectory);
    if (!Files.isDirectory(dir)) {
      throw new RuntimeException("Not a directory: " + reportDirectory);
    }
    if (customerIds == null) {
      applyAllRecommendations(googleAdsClient, reportDirectory);
    } else {
      int recommendationCount = 0;
      for (Long customerId : customerIds) {
        recommendationCount +=
            applyRecommendationsToCustomer(googleAdsClient, reportDirectory, customerId);
      }
      System.out.printf(
          "Applied %s recommendations totally for %s customers. %n",
          recommendationCount, customerIds.size());
    }
  }

  /**
   * Applies all suggested recommendations found in optimization reports in reportDirectory and
   * generates optimization reports for them.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param reportDirectory the path of report directory which has been checked to be a directory.
   * @throws IOException if failure occurs when trying to read or generate reports.
   */
  private void applyAllRecommendations(GoogleAdsClient googleAdsClient, String reportDirectory)
      throws IOException {
    File dir = new File(reportDirectory);
    int customerCount = 0;
    int skipCount = 0;
    int recommendationCount = 0;
    for (File file : dir.listFiles()) {
      if (file.isDirectory() && file.getName().startsWith("recommendation_")) {
        String folderName = file.getName();
        long customerId =
            Long.parseLong(
                folderName.substring(
                    folderName.indexOf("recommendation_") + "recommendation_".length()));
        recommendationCount +=
            applyRecommendationsToCustomer(googleAdsClient, reportDirectory, customerId);
        customerCount++;
      } else {
        skipCount++;
        System.out.println(file + " is skipped.");
      }
    }
    System.out.printf(
        "Skipped %s files totally in %s.%nApplied %s recommendations totally for %s customers.%n",
        skipCount, reportDirectory, recommendationCount, customerCount);
  }

  /**
   * Applies suggested recommendations of customerId found in reportDirectory and generates
   * optimization reports for it.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param reportDirectory the path of report directory which has been checked to be a directory.
   * @param customerId the customer Id to be applied recommendations to and generate reports.
   * @return the number of successfully applied recommendations for the customer.
   * @throws IOException if a failure occurs when trying to read or generate reports.
   */
  private int applyRecommendationsToCustomer(
      GoogleAdsClient googleAdsClient, String reportDirectory, Long customerId) throws IOException {
    Customer oldCustomer =
        getOriginalCustomer(
            Paths.get(reportDirectory, "recommendation_" + customerId, "optiScore.csv"));
    Map<String, AggregatedRecommendation> aggregatedRecommendationMap =
        getRecommendationsFromReports(
            Paths.get(reportDirectory, "recommendation_" + customerId, "recommendations.csv"),
            customerId);
    List<ApplyRecommendationResult> results =
        applyRecommendations(
            googleAdsClient, customerId, new ArrayList<>(aggregatedRecommendationMap.values()));
    generateReports(
        googleAdsClient, oldCustomer, reportDirectory, results, aggregatedRecommendationMap);
    return results.size();
  }

  /**
   * Constructs an original customer with customerId, name and optiScore from optiScore.csv.
   *
   * @param path the path of optiScore.csv.
   * @return the original customer.
   * @throws IOException if a failure occurs when trying to read CSV files.
   * @throws RuntimeException if the first row of NamedCsv is not present.
   */
  private Customer getOriginalCustomer(Path path) throws IOException {
    final Optional<NamedCsvRow> first =
        NamedCsvReader.builder().build(path, StandardCharsets.UTF_8).stream().findFirst();
    if (first.isPresent()) {
      NamedCsvRow row = first.get();
      String customerId = row.getField("CID");
      return Customer.newBuilder()
          .setResourceName(CustomerName.format(customerId))
          .setId(Long.parseLong(customerId))
          .setDescriptiveName(row.getField("AccountName"))
          .setOptimizationScore(Double.parseDouble(row.getField("OptiScore")))
          .build();
    } else {
      throw new RuntimeException(
          "Failed to construct a customer from optiScore.csv. Expected a CSV file specifying CID,"
              + " AccountName, OptiScore.");
    }
  }

  /**
   * Creates a map between a recommendation ID and the aggregated recommendation constructed from
   * recommendations.csv.
   *
   * @param path the path of recommendations.csv.
   * @param customerId the ID of customer whose recommendations are to be read.
   * @return a map between a recommendation ID and its aggregated recommendation.
   * @throws IOException if a failure occurs when trying to read recommendations.csv.
   */
  private Map<String, AggregatedRecommendation> getRecommendationsFromReports(
      Path path, long customerId) throws IOException {
    Map<String, AggregatedRecommendation> aggregatedRecommendationMap = new HashMap<>();
    NamedCsvReader.builder()
        .build(path, StandardCharsets.UTF_8)
        .forEach(
            row -> {
              String recommendationId = row.getField("ID");
              String recommendationType = row.getField("Type");
              String campaignId = row.getField("CampaignId");
              String campaignOptiScore = row.getField("CampaignOptiScore");
              String descriptions = row.getField("Details");
              Recommendation recommendation =
                  Recommendation.newBuilder()
                      .setResourceName(
                          RecommendationName.format(String.valueOf(customerId), recommendationId))
                      .setType(RecommendationType.valueOf(recommendationType))
                      .build();
              Campaign campaign =
                  Campaign.newBuilder()
                      .setResourceName(CampaignName.format(String.valueOf(customerId), campaignId))
                      .setId(Long.parseLong(campaignId))
                      .setOptimizationScore(Double.parseDouble(campaignOptiScore))
                      .build();
              aggregatedRecommendationMap.put(
                  recommendationId,
                  new AggregatedRecommendation(recommendation, campaign, descriptions));
            });
    return aggregatedRecommendationMap;
  }

  /**
   * Applies provided recommendations to customer ID.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the customer ID to be applied recommendations.
   * @param aggregatedRecommendations the list of aggregated recommendations.
   * @return a list of results of applying recommendations.
   */
  private List<ApplyRecommendationResult> applyRecommendations(
      GoogleAdsClient googleAdsClient,
      Long customerId,
      List<AggregatedRecommendation> aggregatedRecommendations) {
    List<ApplyRecommendationOperation> operations = new ArrayList<>();
    for (AggregatedRecommendation aggregatedRecommendation : aggregatedRecommendations) {
      operations.add(
          ApplyRecommendationOperation.newBuilder()
              .setResourceName(aggregatedRecommendation.recommendation.getResourceName())
              .build());
    }
    try (RecommendationServiceClient recommendationServiceClient =
        googleAdsClient.getLatestVersion().createRecommendationServiceClient()) {
      ApplyRecommendationResponse response =
          recommendationServiceClient.applyRecommendation(Long.toString(customerId), operations);
      return response.getResultsList();
    }
  }

  /**
   * Generates optimization reports to report directory for successfully applied recommendations.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customer the customer to be reported with original otiScore before optimization.
   * @param reportDirectory the path of directory to generate reports.
   * @param results the list of ApplyRecommendationResult.
   * @param aggregatedRecommendationMap the map between a recommendation ID and its aggregated
   * recommendation.
   * @throws IOException if a failure occurs when trying to generate reports.
   */
  private void generateReports(
      GoogleAdsClient googleAdsClient,
      Customer customer,
      String reportDirectory,
      List<ApplyRecommendationResult> results,
      Map<String, AggregatedRecommendation> aggregatedRecommendationMap)
      throws IOException {
    Path dir = Paths.get(reportDirectory, "optimization_" + customer.getId());
    if (!Files.exists(dir)) {
      Files.createDirectories(dir);
    }
    Path path = Paths.get(dir.toString(), "optiScore.csv");
    try (CsvWriter csv = CsvWriter.builder().build(path, StandardCharsets.UTF_8)) {
      csv.writeRow("CID", "AccountName", "OldOptiScore", "NewOptiScore")
          .writeRow(
              String.valueOf(customer.getId()),
              customer.getDescriptiveName(),
              String.valueOf(customer.getOptimizationScore()),
              String.valueOf(
                  getOptiScoreOfCustomer(googleAdsClient, String.valueOf(customer.getId()))));
    }
    generateReportsForRecommendations(
        googleAdsClient,
        customer.getId(),
        results,
        aggregatedRecommendationMap,
        Paths.get(dir.toString(), "recommendations.csv"));
  }

  /**
   * Gets the optimization score of customer.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the customer Id.
   * @return the customer's optimization score.
   */
  private double getOptiScoreOfCustomer(GoogleAdsClient googleAdsClient, String customerId) {
    try (GoogleAdsServiceClient googleAdsServiceClient =
        googleAdsClient.getLatestVersion().createGoogleAdsServiceClient()) {
      String query = "SELECT customer.optimization_score FROM customer";
      SearchGoogleAdsStreamRequest request =
          SearchGoogleAdsStreamRequest.newBuilder()
              .setCustomerId(customerId)
              .setQuery(query)
              .build();
      ServerStream<SearchGoogleAdsStreamResponse> stream =
          googleAdsServiceClient.searchStreamCallable().call(request);
      for (SearchGoogleAdsStreamResponse response : stream) {
        for (GoogleAdsRow row : response.getResultsList()) {
          return row.getCustomer().getOptimizationScore();
        }
      }
    }
    throw new RuntimeException("Failed to lookup customer" + customerId);
  }

  /**
   * Generates recommendations.csv to store the results of the successfully applied recommendations
   * line by line.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the customer Id to generate reports for.
   * @param results the list of results of successfully applied recommendations.
   * @param aggregatedRecommendationMap the map between a recommendationID and its
   * aggregatedRecommendation.
   * @param path the Path object of recommendations.csv file.
   * @throws IOException if a failure occurs when trying to write CSV files.
   */
  private void generateReportsForRecommendations(
      GoogleAdsClient googleAdsClient,
      long customerId,
      List<ApplyRecommendationResult> results,
      Map<String, AggregatedRecommendation> aggregatedRecommendationMap,
      Path path)
      throws IOException {
    try (CsvWriter csv = CsvWriter.builder().build(path, StandardCharsets.UTF_8)) {
      csv.writeRow("ID", "Type", "Details", "CampaignId", "OldOptiScore", "NewOptiScore");
      for (ApplyRecommendationResult result : results) {
        AggregatedRecommendation aggregatedRecommendation =
            aggregatedRecommendationMap.get(
                RecommendationName.parse(result.getResourceName()).getRecommendationId());
        Recommendation recommendation = aggregatedRecommendation.recommendation;
        Campaign oldCampaign = aggregatedRecommendation.campaign;
        // The campaign field of Recommendation will be set only when the recommendation affects a
        // single campaign. Otherwise, the query for recommendations will return campaigns whose Id
        // are 0, then all the columns about campaign in recommendations reports will be set 0.0. In
        // that case, just set NewOptiScore to 0.0 in optimization reports.
        csv.writeRow(
            RecommendationName.parse(recommendation.getResourceName()).getRecommendationId(),
            recommendation.getType().toString(),
            aggregatedRecommendation.descriptions,
            String.valueOf(oldCampaign.getId()),
            String.valueOf(oldCampaign.getOptimizationScore()),
            String.valueOf(
                oldCampaign.getId() == 0
                    ? 0.0
                    : getOptiScoreOfCampaign(
                        googleAdsClient,
                        String.valueOf(customerId),
                        String.valueOf(oldCampaign.getId()))));
      }
    }
  }

  /**
   * Gets the optimization score of campaign.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the customer Id.
   * @param campaignId the campaign Id.
   * @return the optimization score of the customer's campaign.
   */
  private double getOptiScoreOfCampaign(
      GoogleAdsClient googleAdsClient, String customerId, String campaignId) {
    try (GoogleAdsServiceClient googleAdsServiceClient =
        googleAdsClient.getLatestVersion().createGoogleAdsServiceClient()) {
      String query =
          "SELECT campaign.optimization_score FROM campaign WHERE campaign.id = " + campaignId;
      SearchGoogleAdsStreamRequest request =
          SearchGoogleAdsStreamRequest.newBuilder()
              .setCustomerId(customerId)
              .setQuery(query)
              .build();
      ServerStream<SearchGoogleAdsStreamResponse> stream =
          googleAdsServiceClient.searchStreamCallable().call(request);
      for (SearchGoogleAdsStreamResponse response : stream) {
        for (GoogleAdsRow row : response.getResultsList()) {
          return row.getCampaign().getOptimizationScore();
        }
      }
    }
    throw new RuntimeException(
        "Failed to lookup campaign " + campaignId + "for customer" + customerId);
  }
}
