// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.ads.googleads.examples.recommendations.optimizations;

import static com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.DEFAULT_REPORT_DIRECTORY;
import static com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.RECOMMENDATION_DIR_PREFIX;
import static com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.RECO_OPTIMIZATION_SCORE_CSV;
import static com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.RECO_OPTIMIZATION_SCORE_CSV_COLUMNS;
import static com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.RECO_RECOMMENDATIONS_CSV;
import static com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.RECO_RECOMMENDATIONS_CSV_COLUMNS;

import com.beust.jcommander.Parameter;
import com.google.ads.googleads.examples.recommendations.optimizations.AcquireOptimizations.AggregatedRecommendation;
import com.google.ads.googleads.examples.utils.ArgumentNames;
import com.google.ads.googleads.examples.utils.CodeSampleParams;
import com.google.ads.googleads.lib.GoogleAdsClient;
import com.google.ads.googleads.v10.enums.RecommendationTypeEnum.RecommendationType;
import com.google.ads.googleads.v10.errors.GoogleAdsError;
import com.google.ads.googleads.v10.errors.GoogleAdsException;
import com.google.ads.googleads.v10.resources.Campaign;
import com.google.ads.googleads.v10.resources.Customer;
import com.google.ads.googleads.v10.resources.Recommendation;
import com.google.ads.googleads.v10.resources.RecommendationName;
import com.google.ads.googleads.v10.services.ApplyRecommendationOperation;
import com.google.ads.googleads.v10.services.ApplyRecommendationResponse;
import com.google.ads.googleads.v10.services.ApplyRecommendationResult;
import com.google.ads.googleads.v10.services.GoogleAdsRow;
import com.google.ads.googleads.v10.services.GoogleAdsServiceClient;
import com.google.ads.googleads.v10.services.GoogleAdsServiceClient.SearchPagedResponse;
import com.google.ads.googleads.v10.services.RecommendationServiceClient;
import com.google.ads.googleads.v8.utils.ResourceNames;
import com.google.common.collect.ImmutableList;
import de.siegmar.fastcsv.reader.NamedCsvReader;
import de.siegmar.fastcsv.reader.NamedCsvRow;
import de.siegmar.fastcsv.writer.CsvWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Applies the recommendations loaded from the recommendation reports generated by
 * AcquireOptimizations.java, then saves the results and the latest optimization scores into the
 * optimization reports of CSV format.
 */
public class ApplyRecommendations {

  private static final String OPTIMIZATION_DIR_PREFIX = "optimization_";
  private static final String OPTI_OPTIMIZATION_SCORE_CSV = "optiScore.csv";
  private static final String[] OPTI_OPTIMIZATION_SCORE_CSV_COLUMNS = {
    "CID", "AccountName", "OldOptiScore", "NewOptiScore"
  };
  private static final String OPTI_RECOMMENDATIONS_CSV = "recommendations.csv";
  private static final String[] OPTI_RECOMMENDATIONS_CSV_COLUMNS = {
    "ID", "Type", "Details", "CampaignId", "OldOptiScore", "NewOptiScore"
  };

  private static class ApplyRecommendationsParams extends CodeSampleParams {

    @Parameter(
        names = ArgumentNames.CUSTOMER_IDS,
        description =
            "Specify a comma-separated list of customer IDs to apply recommendations to. If not"
                + " provided, the recommendations for all the customers found in"
                + " the --reportDirectory will be applied.")
    private List<Long> customerIds;

    @Parameter(
        names = ArgumentNames.LOGIN_CUSTOMER_ID,
        description =
            "Optionally specify the manager account ID which provides access to the customer IDs.")
    private Long loginCustomerId;

    @Parameter(
        names = "--reportDirectory",
        description = "The path of the directory to persist the generated reports.")
    private String reportDirectory = DEFAULT_REPORT_DIRECTORY;
  }

  public static void main(String[] args) {
    ApplyRecommendationsParams params = new ApplyRecommendationsParams();
    if (!params.parseArguments(args)) {

      // Either pass the required parameters for this example on the command line, or insert them
      // into the code here. See the parameter class definition above for descriptions.
      params.customerIds = ImmutableList.of(Long.valueOf("INSERT_CUSTOMER_ID_HERE"));

      // Optional: Specify the login customer ID if your access to the CIDs is via a manager
      // account.
      // params.loginCustomerId = Long.valueOf("INSERT_LOGIN_CUSTOMER_ID_HERE");

      // Optional: To use a different report directory value from the default specified above,
      // uncomment the line below and insert the desired value.
      // params.reportDirectory = "INSERT_REPORT_DIRECTORY_HERE";
    }

    GoogleAdsClient googleAdsClient = null;
    try {
      GoogleAdsClient.Builder builder = GoogleAdsClient.newBuilder().fromPropertiesFile();
      if (params.loginCustomerId != null) {
        builder.setLoginCustomerId(params.loginCustomerId);
      }
      googleAdsClient = builder.build();
    } catch (FileNotFoundException fnfe) {
      System.err.printf(
          "Failed to load GoogleAdsClient configuration from file. Exception: %s%n", fnfe);
      System.exit(1);
    } catch (IOException ioe) {
      System.err.printf("Failed to create GoogleAdsClient. Exception: %s%n", ioe);
      System.exit(1);
    }

    try {
      new ApplyRecommendations()
          .runExample(googleAdsClient, params.customerIds, params.reportDirectory);
    } catch (GoogleAdsException gae) {
      // GoogleAdsException is the base class for most exceptions thrown by an API request.
      // Instances of this exception have a message and a GoogleAdsFailure that contains a
      // collection of GoogleAdsErrors that indicate the underlying causes of the
      // GoogleAdsException.
      System.err.printf(
          "Request ID %s failed due to GoogleAdsException. Underlying errors:%n",
          gae.getRequestId());
      int i = 0;
      for (GoogleAdsError googleAdsError : gae.getGoogleAdsFailure().getErrorsList()) {
        System.err.printf("  Error %d: %s%n", i++, googleAdsError);
      }
      System.exit(1);
    } catch (IOException ioe) {
      System.err.printf("Failed to generate reports. Exception: %s%n", ioe);
      System.exit(1);
    }
  }

  /**
   * Runs the example.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerIds the customer IDs to apply recommendations to.
   * @param reportDirectory the path of the directory to persist the generated reports.
   * @throws IOException if a failure occurs when trying to read or generate reports.
   */
  private void runExample(
      GoogleAdsClient googleAdsClient, List<Long> customerIds, String reportDirectory)
      throws IOException {
    Path reportDir = Paths.get(reportDirectory);
    if (!Files.isDirectory(reportDir)) {
      throw new IllegalArgumentException("Not a directory: " + reportDirectory);
    }

    if (customerIds == null) {
      // If 'customerIds' is not provided, applies the recommendations for all customers found in
      // the report directory.
      applyRecommendationsToAllCustomers(googleAdsClient, reportDirectory);
    } else {
      int numRecommendations = 0;
      for (long customerId : customerIds) {
        numRecommendations +=
            applyRecommendationsToCustomer(googleAdsClient, customerId, reportDirectory);
      }
      System.out.printf(
          "Applied %d recommendations in total to %d customers.%n",
          numRecommendations, customerIds.size());
    }
  }

  /**
   * Applies the recommendations for all customers found in the report directory.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param reportDirectory the path of the directory to persist the generated reports.
   * @throws IOException if a failure occurs when trying to read or generate reports.
   */
  private void applyRecommendationsToAllCustomers(
      GoogleAdsClient googleAdsClient, String reportDirectory) throws IOException {
    int numCustomers = 0;
    int numSkips = 0;
    int numRecommendations = 0;
    for (File file : new File(reportDirectory).listFiles()) {
      if (file.isDirectory() && file.getName().startsWith(RECOMMENDATION_DIR_PREFIX)) {
        String folderName = file.getName();
        long customerId = Long.parseLong(folderName.substring(RECOMMENDATION_DIR_PREFIX.length()));
        numRecommendations +=
            applyRecommendationsToCustomer(googleAdsClient, customerId, reportDirectory);
        numCustomers++;
      } else {
        numSkips++;
        System.out.println(file + " is skipped.");
      }
    }

    System.out.printf(
        "Skipped %d files in total in %s.%nApplied %d recommendations in total to %d customers.%n",
        numSkips, reportDirectory, numRecommendations, numCustomers);
  }

  /**
   * Applies the recommendations for a customer found in the report directory, then generates the
   * optimization reports.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the customer ID to apply recommendations to.
   * @param reportDirectory the path of the directory to persist the generated reports.
   * @return the number of applied recommendations for the customer.
   * @throws IOException if a failure occurs when trying to read or generate reports.
   */
  private int applyRecommendationsToCustomer(
      GoogleAdsClient googleAdsClient, long customerId, String reportDirectory) throws IOException {
    // Loads the customer info, e.g. name, optimization score from the recommendation reports.
    Customer customer =
        loadCustomerInfo(
            Paths.get(
                reportDirectory,
                RECOMMENDATION_DIR_PREFIX + customerId,
                RECO_OPTIMIZATION_SCORE_CSV));

    // Loads the retrieved recommendations from the recommendation reports.
    Map<String, AggregatedRecommendation> aggregatedRecommendations =
        loadRetrievedRecommendations(
            Paths.get(
                reportDirectory, RECOMMENDATION_DIR_PREFIX + customerId, RECO_RECOMMENDATIONS_CSV),
            customerId);

    // Applies the recommendations to the customer.
    List<ApplyRecommendationOperation> operations = new ArrayList<>();
    for (AggregatedRecommendation aggregatedRecommendation : aggregatedRecommendations.values()) {
      operations.add(
          ApplyRecommendationOperation.newBuilder()
              .setResourceName(aggregatedRecommendation.recommendation.getResourceName())
              .build());
    }

    try (RecommendationServiceClient recommendationServiceClient =
        googleAdsClient.getLatestVersion().createRecommendationServiceClient()) {
      ApplyRecommendationResponse response =
          recommendationServiceClient.applyRecommendation(Long.toString(customerId), operations);

      // Generates the optimization reports after applying the recommendations.
      generateOptimizationReports(
          googleAdsClient,
          customer,
          response.getResultsList(),
          aggregatedRecommendations,
          reportDirectory);

      return response.getResultsList().size();
    }
  }

  /**
   * Constructs a {@link Customer} with ID, name and optimization score, loaded from 'optiScore.csv'
   * of the recommendation reports generated by AcquireOptimizations.java.
   *
   * @param csvPath the path to 'optiScore.csv' of the recommendation reports.
   * @return a {@link Customer} instance.
   * @throws IOException if a failure occurs when trying to read CSV files.
   */
  private Customer loadCustomerInfo(Path csvPath) throws IOException {
    final Optional<NamedCsvRow> firstRow =
        NamedCsvReader.builder().build(csvPath, StandardCharsets.UTF_8).stream().findFirst();
    if (firstRow.isPresent()) {
      NamedCsvRow row = firstRow.get();
      long customerId = Long.parseLong(row.getField(RECO_OPTIMIZATION_SCORE_CSV_COLUMNS[0]));
      return Customer.newBuilder()
          .setResourceName(ResourceNames.customer(customerId))
          .setId(customerId)
          .setDescriptiveName(row.getField(RECO_OPTIMIZATION_SCORE_CSV_COLUMNS[1]))
          .setOptimizationScore(
              Double.parseDouble(row.getField(RECO_OPTIMIZATION_SCORE_CSV_COLUMNS[2])))
          .build();
    } else {
      throw new IllegalArgumentException("Failed to construct a customer from " + csvPath);
    }
  }

  /**
   * Creates a map between a recommendation ID and the {@link AggregatedRecommendation}, constructed
   * from the 'recommendations.csv' of the recommendation reports generated by
   * AcquireOptimizations.java.
   *
   * @param csvPath the path to 'recommendations.csv' of the recommendation reports.
   * @param customerId the client customer ID.
   * @return a map between a recommendation ID and the related {@link AggregatedRecommendation}.
   * @throws IOException if a failure occurs when trying to read CSV files.
   */
  private Map<String, AggregatedRecommendation> loadRetrievedRecommendations(
      Path csvPath, long customerId) throws IOException {
    Map<String, AggregatedRecommendation> aggregatedRecommendations = new HashMap<>();
    NamedCsvReader.builder()
        .build(csvPath, StandardCharsets.UTF_8)
        .forEach(
            row -> {
              String recommendationId = row.getField(RECO_RECOMMENDATIONS_CSV_COLUMNS[0]);
              RecommendationType recommendationType =
                  RecommendationType.valueOf(row.getField(RECO_RECOMMENDATIONS_CSV_COLUMNS[1]));
              long campaignId = Long.parseLong(row.getField(RECO_RECOMMENDATIONS_CSV_COLUMNS[4]));
              double campaignOptiScore =
                  Double.parseDouble(row.getField(RECO_RECOMMENDATIONS_CSV_COLUMNS[5]));
              String description = row.getField(RECO_RECOMMENDATIONS_CSV_COLUMNS[3]);

              Recommendation recommendation =
                  Recommendation.newBuilder()
                      .setResourceName(ResourceNames.recommendation(customerId, recommendationId))
                      .setType(recommendationType)
                      .build();

              Campaign campaign =
                  Campaign.newBuilder()
                      .setResourceName(ResourceNames.campaign(customerId, campaignId))
                      .setId(campaignId)
                      .setOptimizationScore(campaignOptiScore)
                      .build();

              aggregatedRecommendations.put(
                  recommendationId,
                  new AggregatedRecommendation(recommendation, campaign, description));
            });

    return aggregatedRecommendations;
  }

  /**
   * Generates the optimization reports to the report directory.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customer the {@link Customer} to generate for.
   * @param applyRecommendationResults the list of {@link ApplyRecommendationResult}.
   * @param aggregatedRecommendations the map between a recommendation ID and its {@link
   *     AggregatedRecommendation}.
   * @param reportDirectory the path of the directory to persist the generated reports.
   * @throws IOException if a failure occurs when trying to create or write CSV files.
   */
  private void generateOptimizationReports(
      GoogleAdsClient googleAdsClient,
      Customer customer,
      List<ApplyRecommendationResult> applyRecommendationResults,
      Map<String, AggregatedRecommendation> aggregatedRecommendations,
      String reportDirectory)
      throws IOException {
    Path optiDir = Paths.get(reportDirectory, OPTIMIZATION_DIR_PREFIX + customer.getId());
    if (!Files.exists(optiDir)) {
      Files.createDirectories(optiDir);
    }

    // Generates 'optiScore.csv' for the optimization reports.
    Path csvPath = optiDir.resolve(OPTI_OPTIMIZATION_SCORE_CSV);
    try (CsvWriter csv = CsvWriter.builder().build(csvPath, StandardCharsets.UTF_8)) {
      csv.writeRow(OPTI_OPTIMIZATION_SCORE_CSV_COLUMNS)
          .writeRow(
              String.valueOf(customer.getId()),
              customer.getDescriptiveName(),
              String.valueOf(customer.getOptimizationScore()),
              String.valueOf(getCustomerOptiScore(googleAdsClient, customer.getId())));
    }

    // Generates 'recommendations.csv' for the optimization reports.
    csvPath = optiDir.resolve(OPTI_RECOMMENDATIONS_CSV);
    try (CsvWriter csv = CsvWriter.builder().build(csvPath, StandardCharsets.UTF_8)) {
      csv.writeRow(OPTI_RECOMMENDATIONS_CSV_COLUMNS);
      for (ApplyRecommendationResult result : applyRecommendationResults) {
        AggregatedRecommendation aggregatedRecommendation =
            aggregatedRecommendations.get(
                RecommendationName.parse(result.getResourceName()).getRecommendationId());
        Recommendation recommendation = aggregatedRecommendation.recommendation;
        Campaign campaign = aggregatedRecommendation.campaign;

        // The Recommendation.campaign field will be set only when the recommendation affects a
        // single campaign. Otherwise, the query for recommendations will return 0 as the campaign
        // ID. In that case, just set the 'NewOptiScore' column to 0.0 in the optimization reports.
        csv.writeRow(
            RecommendationName.parse(recommendation.getResourceName()).getRecommendationId(),
            recommendation.getType().toString(),
            aggregatedRecommendation.description,
            String.valueOf(campaign.getId()),
            String.valueOf(campaign.getOptimizationScore()),
            String.valueOf(
                campaign.getId() == 0
                    ? 0.0
                    : getCampaignOptiScore(googleAdsClient, customer.getId(), campaign.getId())));
      }
    }
  }

  /**
   * Gets the optimization score for a customer.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the client customer ID.
   * @return the customer's optimization score.
   */
  private double getCustomerOptiScore(GoogleAdsClient googleAdsClient, long customerId) {
    try (GoogleAdsServiceClient googleAdsServiceClient =
        googleAdsClient.getLatestVersion().createGoogleAdsServiceClient()) {
      return new AcquireOptimizations()
          .getCustomerInfo(googleAdsServiceClient, customerId)
          .getOptimizationScore();
    }
  }

  /**
   * Gets the optimization score of a campaign.
   *
   * @param googleAdsClient the Google Ads API client.
   * @param customerId the client customer ID.
   * @param campaignId the campaign ID.
   * @return the campaign's optimization score.
   */
  private double getCampaignOptiScore(
      GoogleAdsClient googleAdsClient, long customerId, long campaignId) {
    try (GoogleAdsServiceClient googleAdsServiceClient =
        googleAdsClient.getLatestVersion().createGoogleAdsServiceClient()) {
      String query =
          "SELECT campaign.optimization_score FROM campaign WHERE campaign.id = " + campaignId;

      SearchPagedResponse response =
          googleAdsServiceClient.search(String.valueOf(customerId), query);
      for (GoogleAdsRow googleAdsRow : response.iterateAll()) {
        return googleAdsRow.getCampaign().getOptimizationScore();
      }
    }

    throw new IllegalArgumentException(
        String.format("Campaign not found with ID %d on customer %d", campaignId, customerId));
  }
}
